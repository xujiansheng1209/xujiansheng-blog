import comp from "/Users/ruby/idea_demo/xujiansheng-blog/docs/.vuepress/.temp/pages/java-core/io/io-design-patterns.html.vue"
const data = JSON.parse("{\"path\":\"/java-core/io/io-design-patterns.html\",\"title\":\"Java IO 设计模式总结\",\"lang\":\"zh-CN\",\"frontmatter\":{\"title\":\"Java IO 设计模式总结\",\"category\":\"Java\",\"tag\":[\"Java IO\",\"Java基础\"],\"description\":\"这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。 装饰器模式 装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。 装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。 对于字节流来说， FilterInputStream （对应输入流...\",\"head\":[[\"meta\",{\"property\":\"og:url\",\"content\":\"https://snailcoding.cn/java-core/io/io-design-patterns.html\"}],[\"meta\",{\"property\":\"og:site_name\",\"content\":\"蜗牛のJava宝典\"}],[\"meta\",{\"property\":\"og:title\",\"content\":\"Java IO 设计模式总结\"}],[\"meta\",{\"property\":\"og:description\",\"content\":\"这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。 装饰器模式 装饰器（Decorator）模式 可以在不改变原有对象的情况下拓展其功能。 装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。 对于字节流来说， FilterInputStream （对应输入流...\"}],[\"meta\",{\"property\":\"og:type\",\"content\":\"article\"}],[\"meta\",{\"property\":\"og:locale\",\"content\":\"zh-CN\"}],[\"meta\",{\"property\":\"article:author\",\"content\":\"Mr.Xu\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"Java IO\"}],[\"meta\",{\"property\":\"article:tag\",\"content\":\"Java基础\"}],[\"script\",{\"type\":\"application/ld+json\"},\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Article\\\",\\\"headline\\\":\\\"Java IO 设计模式总结\\\",\\\"image\\\":[\\\"\\\"],\\\"dateModified\\\":null,\\\"author\\\":[{\\\"@type\\\":\\\"Person\\\",\\\"name\\\":\\\"Mr.Xu\\\",\\\"url\\\":\\\"https://snailcoding.cn\\\"}]}\"]]},\"headers\":[{\"level\":2,\"title\":\"装饰器模式\",\"slug\":\"装饰器模式\",\"link\":\"#装饰器模式\",\"children\":[]},{\"level\":2,\"title\":\"适配器模式\",\"slug\":\"适配器模式\",\"link\":\"#适配器模式\",\"children\":[]},{\"level\":2,\"title\":\"工厂模式\",\"slug\":\"工厂模式\",\"link\":\"#工厂模式\",\"children\":[]},{\"level\":2,\"title\":\"观察者模式\",\"slug\":\"观察者模式\",\"link\":\"#观察者模式\",\"children\":[]},{\"level\":2,\"title\":\"参考\",\"slug\":\"参考\",\"link\":\"#参考\",\"children\":[]}],\"git\":{\"createdTime\":null,\"updatedTime\":null,\"contributors\":[]},\"readingTime\":{\"minutes\":7.79,\"words\":2337},\"filePathRelative\":\"java-core/io/io-design-patterns.md\",\"excerpt\":\"<p>这篇文章我们简单来看看我们从 IO 中能够学习到哪些设计模式的应用。</p>\\n<h2>装饰器模式</h2>\\n<p><strong>装饰器（Decorator）模式</strong> 可以在不改变原有对象的情况下拓展其功能。</p>\\n<p>装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。</p>\\n<p>对于字节流来说， <code>FilterInputStream</code> （对应输入流）和<code>FilterOutputStream</code>（对应输出流）是装饰器模式的核心，分别用于增强 <code>InputStream</code> 和<code>OutputStream</code>子类对象的功能。</p>\",\"autoDesc\":true}")
export { comp, data }
